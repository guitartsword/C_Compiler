package c_compiler;

import java_cup.runtime.*;
import java.io.Reader;

parser code {:
  public parser (java.io.Reader input) {
    super(new Lexer(input));
  }
  public void syntax_error(Symbol cur_token){
    System.err.println("Syntax error at "+cur_token);
  }
  public void report_error(String errorBody, Object info) {
    StringBuffer errorHead = new StringBuffer("Error Sintactico");
      if(info instanceof java_cup.runtime.Symbol){
        java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
        if (s.left >= 0) {
          errorHead.append(" en la linea: "+(s.right+1));
          if (s.right >= 0){
            errorHead.append(", columna: "+(s.left+1));
        }
      }
      errorHead.append(" en el token: "+(s.value));
      errorHead.append(" -> "+errorBody);
    }
    System.err.println(errorHead);
  }

:};

terminal          IF, ELSE, WHILE, FOR, INT, DOUBLE, BOOL, CHAR, VOID,
                  RETURN, INCLUDE, LITERAL_BOOL, LPAREN, RPAREN, LBRACKET,
                  RBRACKET, LKEY, RKEY, ASSIGN, OPERATOR_RELATIONAL,
                  OPERATOR_SUM, OPERATOR_MUL, ENDEXP, COMMA,
                  PRINTF, SCANF, LITERAL_CHAR, LITERAL_INT,
                  LITERAL_STRING, IDENTIFIER;

non terminal      program, declaration, typedef, identifier;

program::= declaration {: System.out.println("NO ERROR FOUND"); :}
           |declaration program {:System.out.println("###############");:}
;

declaration::= identifier ENDEXP {:System.out.println("finished");:}
;

identifier::= typedef IDENTIFIER:id {:System.out.println(id);:}
              | identifier COMMA IDENTIFIER:id {:System.out.println(id);:}
;

typedef::= BOOL {:System.out.println("bool");:}
           | INT {:System.out.println("int");:}
           | DOUBLE {:System.out.println("double");:}
           | CHAR {:System.out.println("char");:}
;